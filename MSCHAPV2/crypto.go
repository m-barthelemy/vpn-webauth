// From https://github.com/keysonZZZ/kmg/blob/master/third/kmgRadius/MSCHAPV2/crypto.go
package MSCHAPV2

import (
	"crypto"
	// #nosec
	_ "crypto/sha1"
	// #nosec
	_ "golang.org/x/crypto/md4"
)

// https://datatracker.ietf.org/doc/html/rfc2759#section-8.7
var generateAuthenticatorResponseMagic1 = []byte{0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
	0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
	0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
	0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74}

var generateAuthenticatorResponseMagic2 = []byte{0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
	0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
	0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
	0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
	0x6E}

// RFC2759 section 8.7 page 9
// Return binary form of the result
// in the hash example password is utf-16 encoded.
//    Password = "clientPass" 密码的输入格式比较奇怪.utf16?
// 			   = 63 00 6C 00 69 00 65 00 6E 00
// 				 74 00 50 00 61 00 73 00 73 00
func GenerateAuthenticatorResponse(password []byte, ntResponse [24]byte, peerChallenge [16]byte,
	authenticatorChallenge [16]byte, userName []byte) [20]byte {
	// TODO: Ensure this also works for passwords containing any unicode char
	utf16Password := make([]byte, len(password)*2)
	for i := range password {
		utf16Password[i*2] = password[i]
	}

	// Hash the password with MD4
	passwordHash := md4(utf16Password) //ntPasswordHash

	// Now hash the hash
	passwordHashHash := md4(passwordHash) //hashNtPasswordHash

	h := crypto.SHA1.New()
	h.Write(passwordHashHash)
	h.Write(ntResponse[:])
	h.Write(generateAuthenticatorResponseMagic1)
	digest := h.Sum(nil)

	challenge := challengeHash(peerChallenge, authenticatorChallenge, userName)

	h = crypto.SHA1.New()
	h.Write(digest)
	h.Write(challenge)
	h.Write(generateAuthenticatorResponseMagic2)
	digest = h.Sum(nil)

	out := [20]byte{}
	copy(out[:], digest)
	return out
}

func md4(password []byte) []byte {
	h := crypto.MD4.New()
	h.Write(password)
	return h.Sum(nil)
}

func challengeHash(peerChallenge [16]byte, authenticatorChallenge [16]byte, userName []byte) []byte {
	h := crypto.SHA1.New()
	h.Write(peerChallenge[:])
	h.Write(authenticatorChallenge[:])
	h.Write(userName)
	digest := h.Sum(nil)

	challenge := make([]byte, 8)
	copy(challenge, digest[:8])
	return challenge
}

// "Deriving MPPE Keys From MS-CHAP V2 Credentials", Section 4.3
// https://datatracker.ietf.org/doc/html/draft-ietf-pppext-mschapv2-keys-00.txt#section-4.3
var msCHAPV2GetSendAndRecvKeySHSpad1 = [40]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

var msCHAPV2GetSendAndRecvKeySHSpad2 = [40]byte{0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2}

var msCHAPV2GetSendAndRecvKeyMagic1 = [27]byte{0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
	0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
	0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79}

var msCHAPV2GetSendAndRecvKeyMagic2 = [84]byte{0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
	0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79,
	0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
	0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
	0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
	0x6b, 0x65, 0x79, 0x2e}

var msCHAPV2GetSendAndRecvKeyMagic3 = [84]byte{0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
	0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
	0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
	0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
	0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20,
	0x6b, 0x65, 0x79, 0x2e}

func msCHAPV2GetSendAndRecvKeyGetMasterKey(passwordHashHash []byte, ntResponse [24]byte) (masterkey [16]byte) {
	// Secure Hash Standard Federal Information Processing Standards Publication 180-1 -> SHA1
	h := crypto.SHA1.New()
	h.Write(passwordHashHash)
	h.Write(ntResponse[:])
	h.Write(msCHAPV2GetSendAndRecvKeyMagic1[:])
	Digest := h.Sum(nil)
	copy(masterkey[:], Digest[:16])
	return
}

func msCHAPV2GetSendAndRecvKeyGetAsymetricStartKey(masterkey [16]byte, sessionKeyLength int, isSend bool, isServer bool) (sessionKey []byte) {
	var s [84]byte
	if isSend {
		if isServer {
			s = msCHAPV2GetSendAndRecvKeyMagic3
		} else {
			s = msCHAPV2GetSendAndRecvKeyMagic2
		}
	} else {
		if isServer {
			s = msCHAPV2GetSendAndRecvKeyMagic2
		} else {
			s = msCHAPV2GetSendAndRecvKeyMagic3
		}
	}
	h := crypto.SHA1.New()
	h.Write(masterkey[:])
	h.Write(msCHAPV2GetSendAndRecvKeySHSpad1[:])
	h.Write(s[:])
	h.Write(msCHAPV2GetSendAndRecvKeySHSpad2[:])
	digest := h.Sum(nil)
	sessionKey = digest[:sessionKeyLength]
	return sessionKey
}

// http://www.ietf.org/rfc/rfc3079.txt
//    Password = "clientPass" 密码的输入格式已经修正
// 			   = 63 00 6C 00 69 00 65 00 6E 00
// 				 74 00 50 00 61 00 73 00 73 00
func MsCHAPV2GetSendAndRecvKey(password []byte, ntResponse [24]byte) (sendKey []byte, recvKey []byte) {
	// TODO: Ensure this also works for passwords containing any unicode char
	utf16Password := make([]byte, len(password)*2)
	for i := range password {
		utf16Password[i*2] = password[i]
	}
	passwordHash := md4(utf16Password)
	passwordHashHash := md4(passwordHash)

	masterKey := msCHAPV2GetSendAndRecvKeyGetMasterKey(passwordHashHash, ntResponse)
	masterSendKey := msCHAPV2GetSendAndRecvKeyGetAsymetricStartKey(masterKey, 16, true, true)
	masterReceiveKey := msCHAPV2GetSendAndRecvKeyGetAsymetricStartKey(masterKey, 16, false, true)

	return masterSendKey, masterReceiveKey
}
